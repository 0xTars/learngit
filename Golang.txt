GO语言基础:
    Go程序是通过package来组织的
    package main这一行告诉我们当前文件属于哪个包，而包名main则告诉我们它是一个可独立运行的包，
    它在编译后会产生可执行文件。除了main包之外，其它的包最后都会生成*.a文件
    //和python的if __name__ == '__main__' 类似

导入模块：
    关键字:import
    格式： import ("fmt""name")
//GO的标签名大小写敏感！

定义变量：
    关键字：var
        //定义一个名称为“variableName”，类型为"type"的变量
        var variableName type
    定义多个变量
        //定义三个类型都是“type”的变量
        var vname1, vname2, vname3 type
    定义变量并初始化值
        //初始化“variableName”的变量为“value”值，类型是“type”
        var variableName type = value
    同时初始化多个变量
        /*
        定义三个类型都是"type"的变量,并且分别初始化为相应的值
        vname1为v1，vname2为v2，vname3为v3
        */
        var vname1, vname2, vname3 type= v1, v2, v3

    自动初始化： // 简短声明 :=   //只能用在函数内部
       /*
       定义三个变量，它们分别初始化为相应的值
       vname1为v1，vname2为v2，vname3为v3
       编译器会根据初始化的值自动推导出相应的类型
       */
       vname1, vname2, vname3 := v1, v2, v3
    特殊变量名：
      _（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃，我们将值35赋予b，并同时丢弃34：
      _, b := 34, 35

      例子：
      //示例代码
      var isActive bool  // 全局变量声明
      var enabled, disabled = true, false  // 忽略类型的声明
      func test() {
          var available bool  // 一般声明
          valid := false      // 简短声明
          available = true    // 赋值操作
      }

常量：    //常量可定义为数值、布尔值或字符串等类型。
    关键字：const
        语法：
        const constantName = value
        //如果需要，也可以明确指定常量的类型：
        const Pi float32 = 3.1415926
    //Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)，
        若指定給float32自动缩短为32bit，指定给float64自动缩短为64bit

     布尔值：bool   值为：true或false，默认为false。
     整数类：int & uint
           定义好位数的类型:rune, int8, int16, int32, int64和byte, uint8, uint16, uint32,uint64。其中rune是int32的别称，byte是uint8的别称。
     浮点数：float32 & float64      默认是float64。
     复数：complex128（64位实数+64位虚数）。也有complex64(32位实数+32位虚数)
     字符串：string       //用一对双引号（""）或反引号（）括起来定义

流程控制:
     Go中流程控制分三大类：条件判断，循环控制和无条件跳转。
     if
       if也许是各种编程语言中最常见的了，它的语法概括起来就是:如果满足条件就做某事，否则做另一件事。
       Go里面if条件判断语句中不需要括号
     goto
       Go有goto语句——请明智地使用它。用goto跳转到必须在当前函数内定义的标签。
     for
       Go里面最强大的一个控制逻辑就是for，它即可以用来循环读取数据，又可以当作while来控制逻辑，还能迭代操作。
     break：跳出当前循环
     continue:跳过本次循环
     switch:    //选择语句，配合case使用  //多条件判断

函数：
     关键字：func   //Go语言可以返回多个值
     格式：func funcName(参数1 类型，参数2 类型 ...) (返回值1 类型, 返回值2 类型){
     code
        return value1,value2
     }

     变参：参数类型前面加省略号 ...
     格式：func myfunc(arg ...int) {}

     传值与传指针：
         传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy。
         当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化。
      指针：
      *指针类型   操作取的得地址的值
      &取地址

延迟语句：
      关键字：defer    //类似python中的析构函数
      多个defer语言执行栈模式 //先进后出
函数作为值、类型
      在Go中函数也是一种变量，我们可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型
      type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...])
恐慌：   //类似java和python的异常处理
      恐慌可以直接调用panic产生。也可以由运行时错误产生，例如访问越界的数组。
      Panic:产生恐慌
      Recover：从恐慌中恢复  //必须在defer语句中使用
      例
        defer func() {
          if x := recover(); x != nil {
              b = true
          }
        }()

main函数和init函数
      init函数（能够应用于所有的package）
      main函数（只能应用于package main）
      每个package中的init函数都是可选的，但package main就必须包含一个main函数。
      Go程序自动调用init()和main()

结构体：    //类似java和python中的class
      关键字：struct
      语法：type structname struct{}

      匿名字段：  //实现字段继承。
      当匿名字段是一个struct的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个struct。

方法：method
      语法：func (r ReceiverType) funcName(parameters) (results)
      和函数基本相同，多了在函数后面加上一个接收值。
      可以现实匿名字段。

接口：interface
      inteerface是一组method的组合。
      空interface：可以存储任意类型的数值。
      例：
      // 定义a为空接口
        var a interface{}
        var i int = 5
        s := "Hello world"
        // a可以存储任意类型的数值
        a = i
        a = s
Comma-ok断言
       Go语言里面有一个语法，可以直接判断是否是该类型的
       变量： value, ok = element.(T)，这里value就是变量的值，
       ok是一个bool类型，element是interface变量，T是断言的类型。
       如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。

并发：  goroutine   //线程       //并行中并发
       关键字：go
       语法:go hello(a, b, c)

通道：  channels
        关键字：make  chan
        语法make(chan 类型)
            ci := make(chan int)
            cs := make(chan string)
            cf := make(chan interface{})
        channel通过操作符<-来接收和发送数据
            ch <- v    // 发送v到channel ch.
            v := <-ch  // 从ch中接收数据，并赋值给v
        阻塞：
        channels有缓存和无缓存；  //数据等待和不等待
        ch := make(chan type, value)  //value为指定存储元素
        value == 0 ! 无缓冲（阻塞）
        value > 0 ! 缓冲（非阻塞，直到value 个元素）

        关键字：range  不断读取指定参数的值
        语法： of i := range c   //c为通道
        关键字：close   关闭通道
        语法：close(c)
        监听：select    监听channel上的数据流动，默认阻塞 和switch类型
              default：当监听的channel都没有准备好的时候，默认执行的（select不再阻塞等待channel）。
        用法：
        select {
        case i := <-c:
            // use i
        default:
            // 当c阻塞的时候执行这里
        }
runtime goroutine:
        runtime包中有几个处理goroutine的函数：
        Goexit：
        退出当前执行的goroutine，但是defer函数还会继续调用
        Gosched：
        让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。
        NumCPU：
        返回 CPU 核数量
        NumGoroutine：
        返回正在执行和排队的任务总数
        GOMAXPROCS：
        用来设置可以并行计算的CPU核数的最大值，并返回之前的值。

Go语言关键字：
        break    default      func    interface    select
        case     defer        go      map          struct
        chan     else         goto    package      switch
        const    fallthrough  if      range        type
        continue for          import  return       var
