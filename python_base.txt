#!/usr/bin/env python3
# -*- coding: utf-8 -*-
python程序大小写敏感
转义字符'\'       #\n \t
字符串前面加r''表示''内部的字符串默认不转义


数据类型：
      整数：整数
      浮点：小数
      布尔：Ture/False
      字符串：'python'

逻辑运算符：and、or、not   /与 或 非  #支持布尔运算
空值：None

数值运算
    /   除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数
    //  称为地板除，两个整数的除法仍然是整数：
    %   两个整数相除的余数

编码：一个字节(byte)占8个比特(bit)，一个字节最大的整数为255
在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码

字符串前面加b''表示''内部的数据为'bytes'类型  #bytes的每个字符都只占用一个字节
以Unicode表示的str通过encode()方法可以编码为指定的bytes

格式化方式：
      用%实现
          %运算符就是用来格式化字符串的。
          在字符串内部，%s表示用字符串替换，
          %d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。
          如果只有一个%?，括号可以省略。
      常见的占位符
          %d	整数
          %f	浮点数
          %s	字符串
          %x	十六进制整数
      用方法实现
          使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，

列表：list
      一种有序的集合，可以随时添加和删除其中的元素,元素可以为不同类型
      可以看做一个数组：list[][]
      list=[a,b,c]
      获取列表元素的个数：len()
      索引：list[0,1,2]
      在list末尾追加元素：append(元素)
      在list指定位置追加元素：insert(索引,元素)
      删除指定位置的元素:pop(索引)
      元素替换：list[1]=d    list[a,d,c]
      列表中的列表：list[a,d,c,['b',a,3]]

元组：tuple
      //初始化后不能修改元素 只能获取元素：tuple=()
      定义1个远古的元组时后面必须加','号  // t=(1,)
      可以在元组中加入列表，列表的元素可以改变

字典：dict
      使用键-值（key-value）存储：dict={'a':1,'b':2}
      一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉
      避免key不存在的错误：通过in判断key是否存在：'a' in dict   >>>Ture
                         通过get()方法：dict.get('a')
      //dict内部存放的顺序和key放入的顺序是没有关系的。

集合：set   //没有值的字典使用关键字set 不允许重复元素
      要创建一个set，需要提供一个list作为输入集合：s=set([1,2,3])
      添加元素到set中：add(key)
      删除元素：remove(key)



条件判断:   //条件判断后面要加':'号
      if else
       简写：
       if x:
            print('True')
       只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。
循环：
    第一种:for
    for x in ...    把每个元素代入变量x，然后执行缩进块的语句
    for x in range(101): 循环0-100
    第二种:while
    while n>0: 只要条件成立，就会不断循环
    while True:
    中止循环：break
    跳过当前这次循环：continue

函数：def
    一种规则的封装
    def 函数名(参数):
    语句
    return 返回值
    默认参数
    定义默认参数要牢记一点：默认参数必须指向不变对象！

    可变参数  //可变参数允许你传入0个或任意个参数
    在参数前面加上'*'   //*args  接收一个元组

    关键字参数  //**kw    接收一个字典
    关键字参数允许你传入0个或任意个含参数名的参数

    命名关键字参数  //name,age,*,city,job
    命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。

    递归函数：//函数内部调用自身函数

切片： //去尾不去头 和golang一样 后面数减去前面的数为取的个数
    L=[0:3]    index=0,1,2
    前10个数，每两个取一个：>>> L[:10:2]      [0, 2, 4, 6, 8]
    所有数，每5个取一个：>>> L[::5]
    复制一个list:L[:]

迭代:  //list和tuple的遍历   for...in
    字典的遍历默认为key，如果要迭代value，要用for value in dict.value().如果要同时迭代key和value，可以用for k, v in dict.items()。
    字符串也可用于迭代
    判断一个对象是否为可迭代对象：isinstace(判断对象，Iterable)
    迭代元素和下标：for i,value in enumenrate['a','b','c']
    任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。

列表生成式：range
    //
    list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))
    [1x1, 2x2, 3x3, ..., 10x10]   [x * x for x in range(1, 11)]
    可以加条件判断 :[x * x for x in range(1, 11) if x % 2 == 0]
    可以使用多个变量：
        d = {'x': 'A', 'y': 'B', 'z': 'C' }
        for k, v in d.items():

    双冒号：step  //间隔  [开始值:数目值：差值]
    range(10)[:10:2] #开始start省略时，默认从第0项开始
    [0,2,4,6,8]
    range(10)[1::2]  #结尾省略的时候，默认到数组最后。
    [1,3,5,7,9]
    range(10)[2:6:]#开始和结尾不省略step省略默认为1
    [2,3,4,5]
    range(20)[::3]  #步长step=n;代表从start开始（start也算）每隔step间隔，取一个数，一直到结尾end
    [0,3,6,9,12,15,18]
    range(10)[::-1] 当step等于负数的时候，从右向左取数。
    [9,8,7,6,5,4,3,2,1,0]

生成器:generator
    只要把一个列表生成式的[]改成()，就创建了一个generator：
    g=(x * x for x in range(10))
    1.通过方法next(g)一个一个取
    2.通过for循环for n in g:

    函数生成器：
    关键字yield：在函数print出替换成yield就是一个generator
    def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
    在for循环中调用generator会拿不到return的值，
    必须捕获StopIteration错误，返回值包含在StopIteration的value中
    g = fib(6)
>>> while True:
...     try:
...         x = next(g)
...         print('g:', x)
...     except StopIteration as e:
...         print('Generator return value:', e.value)
...         break

迭代器：//可以直接作用于for循环的对象统称为可迭代对象：Iterable
      使用isinstance()判断一个对象是否是Iterable对象：
      >>> from collections import Iterable
      >>> isinstance([], Iterable)
      可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator
      生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。
      把list、dict、str等Iterable变成Iterator可以使用iter()函数
      >>> isinstance(iter([]), Iterator)
      True
      >>> isinstance(iter('abc'), Iterator)
      True

高阶函数：
      函数本身也可以赋值给变量，即：变量可以指向函数。
      把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式

map()/reduce()：
      一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现
      用代码实现：
      >>> def f(x):
      ...     return x * x
      ...
      >>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
      >>> list(r)
      [1, 4, 9, 16, 25, 36, 49, 64, 81]

      reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算
      >>> from functools import reduce
      >>> def fn(x, y):
      ...     return x * 10 + y
      ...
      >>> reduce(fn, [1, 3, 5, 7, 9])
      13579

filter()
      Python内建的filter()函数用于过滤序列
      filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素
      def is_odd(n):
      return n % 2 == 1
      list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
      # 结果: [1, 5, 9, 15]

sorted()
      接收一个key函数来实现自定义的排序,sorten本身按照从小到大排序，对字符串排序，是按照ASCII的大小比较的
      >>> sorted([36, 5, -12, 9, -21], key=abs)
      [5, 9, -12, -21, 36]

返回函数   // 闭包 程序结构
      在一个函数中不需要立刻实现功能而是根据需要在实现，就需要用返回函数
      def lazy_sum(*args):
      def sum():
          ax = 0
          for n in args:
              ax = ax + n
          return ax
       return sum
       调用lazy_sum()时，返回的并不是求和结果，而是求和函数
       ！！返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量
       def count():
       fs = []
          for i in range(1, 4):
              def f():
                   return i*i
              fs.append(f)
          return fs

      f1, f2, f3 = count()
      f1, f2, f3 = 9,9,9
      如果一定要引用循环变量，方法是再创建一个函数
      def count():
      def f(j):
          def g():
              return j*j
          return g
      fs = []
      for i in range(1, 4):
          fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
      return fs
      f1, f2, f3 = count()
      f1, f2, f3 = 1,4,9

匿名函数：关键字lambda  //只能有一个表达式，不用写return，返回值就是该表达式的结果
      >>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
      [1, 4, 9, 16, 25, 36, 49, 64, 81]
      匿名函数lambda x: x * x实际上是
      def f(x):
      return x * x
      关键字lambda表示匿名函数，冒号前面的x表示函数参数。
      把匿名函数作为返回值返回
      def build(x, y):
          return lambda: x * x + y * y

  装饰器：Decorator
      要增强一个函数的功能，但又不希望修改函数的定义，这种在运行期间动态增加功能的方式，称为装饰器
      本质上，decorator就是一个返回函数的高阶函数（闭包）
      def log(func):   #func表示接收一个函数变量
      def wrapper(*args, **kw):   #*args是非关键字参数，用于元组，**kw是关键字参数，用于字典
          print('call %s():' % func.__name__)
          return func(*args, **kw)
      return wrapper
      观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：
      @log
      def now():
          print('2018-3-19')
      调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：
      >>> now()
      call now():
      2018-3-19
      把@log放到now()函数的定义处，相当于执行了语句：now = log(now)
      如果装饰器本身需要传递参数，那就需要编写一个返回装饰器的高阶函数 #三层嵌套
      def log(text):
      def decorator(func):
          def wrapper(*args, **kw):
              print('%s %s():' % (text, func.__name__))
              return func(*args, **kw)
          return wrapper
      return decorator
      用法：
      @log('execute')
      def now():
          print('2018-3-19')
      执行结果如下：
      >>> now()
      execute now():
      2018-3-19
      和两层嵌套的decorator相比，3层嵌套的效果是这样的:
      >>> now = log('execute')(now)
      首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。
      原始函数的属性复制到嵌套函数中：
      使用python自带的方法：functools.wraps
      完整的decorator的写法如下
      import functools

      def log(func):
          @functools.wraps(func)
          def wrapper(*args, **kw):
              print('call %s():' % func.__name__)
              return func(*args, **kw)
          return wrapper

      针对带参数的decorator：
      import functools

      def log(text):
          def decorator(func):
              @functools.wraps(func)
              def wrapper(*args, **kw):
                  print('%s %s():' % (text, func.__name__))
                  return func(*args, **kw)
              return wrapper
          return decorator

偏函数：
    Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function ）
    functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
    base参数用于表示进制，入base=2，base=8  value代表进制
    >>> import functools
    >>> int2 = functools.partial(int, base=2)
    >>> int2('1000000')   #代表int2传入的值为2进制
    64
    创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数。

第三方模块：
    安装第三方模块，是通过包管理工具pip完成的
    pip install 模块名
安装常用模块
    推荐直接使用Anaconda，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。
    添加自己的搜索目录，有两种方法：
        1,直接修改sys.path，添加要搜索的目录
        >>> import sys
        >>> sys.path.append('/Users/michael/my_py_scripts')
        2,置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。


面向对象：//继承 封装 多态  简称OOP
   一种函数的封装

      类和实例：
      面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，
      而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同

      特殊的__init__方法：初始化属性，第一个参数永远是self，self指向的是实例本身
      和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，
      所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。

      静态属性：在属性名称前加两个下划线__ 类似java中private//外部不能访问。
      获取静态属性：添加get方法
      def get_属性名(self)
          return self__属性名
      允许外部修改属性：增加set方法
      def set_属性名(self, 属性名)
          self.__属性名=属性名
      在这种方法中，可以对参数做检查，避免传入无效的参数

      ！！在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，
      特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名

      私有属性也可以访问，python解释器把私有属性变成了_类名__私有属性名，可以通过这个方法来访问私有变量

  继承：在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），
        而被继承的class称为基类、父类或超类（Base class、Super class）。
        //python允许多重继承
  多态：当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。
        这样，我们就获得了继承的另一个好处：多态。
  判断一个变量是否是某个类型可以用isinstance()判断：isinstance(实例， 类)
  对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用
  在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力

  “开闭”原则:
      对扩展开放：允许新增Animal子类；
      对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。

  获取对象信息:
      使用type()  //type(123) >>>int    //type（123）==type（456） >>>True
      判断基本数据类型可以直接写int，str等，要判断一个对象m可以使用types模块中定义的常量：//import types
      def fn()
      type(fn)==types.FunctionType  >>>True
      使用isinstance()  a=Animal() d=Dog() h=Husky()
      //isinstace(h.husky) >>>True //isinstace(h.dog) >>>True

      如果要活的一个对象的所有属性和方法，使用dir()函数，返回包含一个字符串的列表
      >>> dir('ABC')
      ['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
      >>> hasattr(obj, 'power') # 有属性'power'吗？
      True
      >>> getattr(obj, 'power') # 获取属性'power'
      <bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>

      实例属性和类属性不是一个东西，绑定不一样的属性。

  限制实例属性：
      使用__slots__特殊变量
      只允许对Student实例添加name和age属性。
      class Student(object):
            __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
限制属性更改：
      使用@property装饰器:负责把一个方法变成属性调用的
      @score.setter：负责把一个setter方法变成属性赋值

定制类： //特殊方法和特殊变量
      __str__():返回用户看到的字符串
      __repr__()：返回程序开发者看到的字符串
      __iter__():返回一个迭代对象
      __next__():自动迭代取值
      __getitem__()：像list那样按照下标取出元素
      __getattr__()：没有找到属性时，动态返回一个属性
      __setattr__()：设置对象的属性
      __call__():直接对实例进行调用 #  通过callable()函数，我们就可以判断一个对象是否是“可调用”对象

枚举类：//自定义数据类型
      为枚举类型定义一个class类型，每个常量都是class的一个唯一实例，用Enum()
      from enum import Enum
      Month = Enum('Month',
      ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

      装饰器@unique #帮助我们检查保证没有重复值

元类：
      使用type()函数Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
      要创建一个class对象，type()函数依次传入3个参数：
      class的名称；
      继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；
      class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。

      使用metaclass //元类  控制类的创建行为，用于创建类的时候

异常处理：
        try：  #如果以下的代码出现except的异常
            可能会出现异常的代码
        except 异常名称: #出现该异常就执行下列代码    //可以执行多个except
            出现该异常后的处理方式
        finally： #异常处理结果 可以不写
            处理的结果
        ！异常中用Exception可以表示只要出现异常就捕获。

        错误日志: #python内置的logging模块可以非常容易地记录错误信息
        try:
            可能出错的代码
        except Exception as e:
            logging.exception(e)  #记录错误日志

        抛出异常：#raise   自定义异常
        if xxx
          raise 异常名称(参数)
        当处理不了一个异常时候可以往上抛，
        raise语句如果不带参数，就会把当前错误原样抛出。
        此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型
        try:
            10 / 0
        except ZeroDivisionError:
            raise ValueError('input error!')

调试：
      1.用print()打印可能出错的变量
      2.使用断言assert, 凡是使用print的地方都用断言代替,断言失败跑出AssertionError异常。 -0参数关闭断言
      3.把print()替换为logging，不会抛出异常，会输出一段文本。
            需要导入logging模块,并配置:logging.basicConfig(level=logging.INFO)
            logging允许指定记录信息级别：debug，info，warning，error等几个级别
      4.pdb,python的调试器，让程序单步运行，python -m pdb err.py，
            输入命令n可以单步执行代码,任何时候都可以输入命令p 变量名来查看变量(Pdb) p 变量名
      5.pdb.set_trace()，需要导入pdb包,在可能出错的地方放一个pdb.set_trace()，在出错代码上方放置
            运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境
      6.IDE，pycharm VS 等自带的调试功能

单元测试：需要导入python自带的unittest模块,测试类需要继承(unittest.TestCase):
      把每个实例放到值中self.assertEqual(实例，期望值) //
      或者在可能出错实例上断言，并指定期望跑出的异常with self.assertRaises(异常类型):
      每个测试方法前需要加test，比如test_attrerrore
运行单元测试：  1.运行方式是在mydict_test.py的最后加上两行代码:
                if __name__ == '__main__':
                unittest.main()
               2.在命令行通过参数-m unittest直接运行单元测试
单元测试中的两个特殊方法：setUp()和tearDown():分别在每调用一个测试方法的前后分别被执行

文档测试：在代码注释中写文档示例，并通过python内置文档测试模块提取注释代码并执行测试
         调用方式：
          if __name__=='__main__':
          import doctest
          doctest.testmod()
